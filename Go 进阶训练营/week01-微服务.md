### 单体服务的困局  

1.尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。

2.应用无法扩展，可靠性很低

3.最终，敏捷性开发和部署变的无法完成。

所以微服务产生了，解决的思路就是：*化繁为简，分而治之*

### 微服务起源

* SOA（面向服务）是啥

  * 服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展

  * **单一职责，**一个服务只做一件事情
  * **尽可能的早的创建原型，**先定义 API，达成契约
  * **可移植性比效率更重要，**通讯协议的可移植性更加重要

* SOA 和 微服务 是什么关系？

  * 你可以把微服务想成是 SOA 的一种实践。

* 微服务是什么？

  * **围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。**

### 微服务的优缺点

- 优点

  - 服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展
  - **原子服务，**一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去
  - **独立进程，**一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处
  - **隔离部署，**每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本
  - 去中心化服务治理
    - 数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台
    - 治理去中心化
    - 技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的

- 缺点

  - 服务之间的依赖关系复杂

    ，成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。

    - 常见的解决方案：全链路追踪，例如， opentracing

  - 微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题

    - 例子：服务调用流量会容易被放大，如果 服务 A -> B ->C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的
    - **常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡**

  - 会有分布式事务问题，

    因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦

    - 常见解决方案：两阶段提交、TCC 等
    - [小米信息部技术团队: 分布式事务，这一篇就够了](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)

  - 测试会非常复杂，

    由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题

    - 常见解决方案：独立测试环境，后面会有一个解决方案

  - 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。

    - 切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，**时刻谨记保持服务契约(接口)的兼容性**
    - 发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。

  - 对运维和基础建设的要求很高，

    基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等

    - 常见解决方案：上云

### 微服务如何构建？

传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go如何 实施一个微服务：

> 多个微服务组合(compose)完成了一个完整的用户场景(usecase)。

- kit：一个微服务的基础库(框架)。
- service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务
- rpc + message queue：轻量级通讯



### 微服务网关 API- Gateway 设计

![01_Go进阶训练营_微服务_v1.svg](https://img.lailin.xyz/image/1606552913072-f2ae26c9-6897-4dc8-9384-95f493ff5006.svg)

流量链路是什么？

- 移动端 -> API Gateway -> BFF -> 微服务
- 不含 CDN、负载均衡（LB）
- BFF 纯 web 的业务一般用 nodejs 做 SSR

为什么我们的服务不直接对外进行暴露？

- 前端（移动端、客户端、web）同学非常痛苦，需要对接多个服务，兼容性差，沟通效率低
- 后端同学也很痛苦，一年前的版本都有人使用，服务无法进行重构升级

为什么需要最外层的 api gateway?

- 基础库的同学非常痛苦，限流熔断安全等业务无关的功能需要进行升级的时候升不动
-  客户端到微服务直接通信，强耦合。
- **需要多次请求，客户端聚合数据，工作量巨大，延迟高**
- 协议不利于统一，各个部门间有差异，需要前端来兼容
- *面向**端***的**API**适配，耦合到了内部服务
- 多终端兼容逻辑复杂，每个服务都需要处理
- 统一逻辑无法收敛，比如安全认证、限流。

API Gateway 的优点

* 轻量交互：协议精简、聚合
* 差异服务：数据裁剪以及聚合、针对终端定制化API

* 动态升级：原有系统兼容升级，更新服务而非协议

* 沟通效率提升，协作模式演进为移动业务**+**网关小组

### 微服务如何拆分？

- 在对业务领域不是特别熟悉的时候，按照

  部门职能进行划分，例如账号、财务等

  - 注意划分的时候**要闭环**，不要相同的功能散落到几个部门当中

- 在系统稳定之后，积累了相关的业务经验和微服务开发经验之后，再考虑使用 DDD 限界上下文进行划分

- 如果可以闭环的解决一个用户场景，那么它应该是一个微服务

- 还可以根据访问频率进行区分划分，将用户高频访问的部分划分为一个服务

- 还可以根据读写进行划分

  - CQRS: 将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新

![01_Go进阶训练营_微服务_v1.svg](https://img.lailin.xyz/image/1606631756304-ac2b31e1-771a-45e7-9b99-5234badc5d0d.svg)

### 微服务之间的安全设计

![01_Go进阶训练营_微服务_v1.svg](https://img.lailin.xyz/image/1606632869613-c887da17-ec2f-4221-822a-84bbd21e4d3f.svg)

在内网主要看安全级别一般有三种：

- Full Trust：假定内网服务之间是安全的，在内网裸奔
- Half Trust：内网服务之间需要进行认证鉴权，但是不需要所有的都进行加密
- Zero Trust: 零信任，任务内部网络是不安全的，类似公网，所有的请求通过身份认证鉴权之后，都需要通过安全加密，防止被嗅探
  - https://www.microsoft.com/en-us/security/business/zero-trust

### 微服务直接为什么要用grpc

- 为什么采用 gRPC?

  - **多语言：**语言中立，支持多种语言。

  - **轻量级、高性能：**序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。

  - **可插拔**

  - **IDL：**基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。

  - 移动端：基于**标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用**、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加**省电和节省网络流量**。

  - **服务而非对象、消息而非引用：**促进微服务的系统间粗粒度消息交互设计理念。

  - **负载无关的：**不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML 和 Thrift。

  - 流：Streaming API。

  - **阻塞式和非阻塞式：**支持异步和同步处理在客户端和服务端间交互的消息序列。

  - 元数据交换：

    常见的横切关注点，如认证或跟踪，依赖数据交换。

    - metadata

  - **标准化状态码：**客户端通常以有限的方式响应 API 调用返回的错误。

- 为什么不使用 restful

  - 每个客户端都需要单独写 SDK，复杂麻烦
  - 需要单独写文档，常常会因为代码更新了但是文档没更新陷入坑中
  - 性能不太好，json 传递相对于 pb 更耗流量，性能更低
  - http1.1 是一个单连接的请求，在内部网络环境，使用 http 比较浪费
  - **restful 是一个松散约束的协议，非常灵活，每个人，每个团队出来的代码都不太一样，比较容易出错**

